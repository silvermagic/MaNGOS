### 简介

本项目用于探索`C++`大型组件开发(类似`Nova Compute`这种级别)，我这边通过重构一个游戏伺服器源码的方式来践行下自己的方法论，其改编自腾讯代理的一款很老的游戏的JAVA版本(项目完成时间不确定，如果有些子系统想不到优雅的处理方式，可能会推后)。本项目采用[MaNGOS](https://github.com/mangos/)的框架进行开发(这个是魔兽世界伺服的实现，虽然这是游戏框架，但是其很多设计依然能适用于其他场景)，项目仅用于交流，不得用于商业用途。

> 我的开发准则

- 尽量不要重复造轮子，如果实在有需要，尽量准备多的使用样例供别人参考或者写好文档
- 尽量使用通用的框架或库，例如Boost，最好网上一搜就有一大堆用法参考的，这样可以降低其他人的学习成本，提升别人的学习意愿，毕竟没几个人愿意学你的私人库，同时这些库本身就是支持跨平台的，就不用自己去处理一些跨平台的问题
- 尽量少使用模板编程，如果实在有需要，最好封装好，类似STL的vector这样，底层实现尽量对使用者透明
- 坚持迭代开发，对于我自己来说，很多时候一开始并没有办法考虑到所有细节，所以很多时候不可能设计的十全十美才进行开发(K8S一开始为了同时兼容docker和rkt也是直接写了两套代码，后面才统一成CRI)，但是一个"粗糙"的原型，不仅能快速进行技术验证，同时还能让你及时发现自己设计上的不足

### 基础框架

在大型组件开发过程中，我们来看下最常见的几个问题:

- 一般大型组件都是TCP服务器，所以我们需要处理套接字的监听，以及网络数据的收发
- 数据并不能都保存在内存中，有些数据需要持久化，所以我们需要处理数据库的连接，以及增删改查
- 有些时候还处理某些定时任务，例如上报心跳

下面我们来看下本项目使用的框架是如何演进的:

> 原始框架

JAVA版本天堂伺服模拟器使用多线程的方式来处理套接字的监听，当收到请求时，启动一个专门的线程来处理这个套接字连接，然后不管是数据的收发、文件的读取，或者数据库存取都在这个线程中处理，这种模型优势在于业务逻辑直观，因为其业务逻辑都是在一个线程内串行执行，缺点是程序设计不好的话(例如需要同时访问多个公共资源的场景)，容易造成死锁。

针对这个模型的优化点就是使用资源池，例如线程池，给定一个初始值，当短时间内出现连接数超过线程池的数量时才创建新的线程，类似vector的增长逻辑，线程使用后回收，如果当前线程数量超过给定的初始值，则直接删除线程，否则放回线程池继续复用，同理数据库也可以有连接池。

```
class 网络线程
{
    void run()
    {
        业务逻辑;
    }
    
    套接字连接;
};

while (停止标识 == false)
{
    新的连接 = 监听套接字.accept();
    线程池.schedule(new 网络线程(新的连接));
}
```

![image](https://upload.wikimedia.org/wikipedia/commons/0/0c/Thread_pool.svg)

> 当前框架

游戏和很多组件(例如Nova Compute)一样，大部分都是计算密集型，而不是I/O密集型的，所以使用I/O多路复用技术能有效降低降低线程切换和资源竞争带来的开销，所以很自然用EPOLL模型来处理套接字连接(为了支持跨平台和EPOLL封装，我直接使用了BOOST的ASIO库，而MaNGOS使用的是ACE网络编程库)，这样我们就可以异步处理套接字的收发。

```
class 异步套接字
{
    void update()
    {
        数据发送缓存 -> 数据;
        套接字连接.async_write(数据);
    }

    void start()
    {
        套接字连接.async_read(异步读回调函数);
    }
    
    void 异步读回调函数()
    {
        业务逻辑(数据); // 数据 -> 数据接收缓存;
        数据 -> 数据发送缓存;
        套接字连接.async_read(异步读回调函数);
    }

    数据接收缓存;
    数据发送缓存;
    套接字连接;
}

class 异步套接字管理
{
    void add()
    {
        新的异步套接字 -> 临时并发队列;
    }
    
    void update()
    {
        定期执行;
        
        临时并发队列 -> 新的异步套接字;
        新的异步套接字 -> 异步套接字列表;

        for (异步套接字 : 异步套接字列表)
        {
            异步套接字.update();
        }
    }

    临时并发队列;
    vector<异步套接字> 异步套接字列表;
};

std::thread 业务主线程(异步套接字管理);
while (停止标识 == false)
{
    新的连接 = 监听套接字.accept();
    异步套接字对象 = new 异步套接字(新的连接);
    异步套接字对象.start();
    异步套接字管理.add(异步套接字对象);
}
```

然而`C++`中有很多操作并不能很方便直接改成异步，例如数据库操作，因为很多数据库的`C++`库并没有提供异步操作的接口，所以为了将这些操作改成统一的异步模式，我们还是需要引入异步请求处理线程，但是不同于多线程模型，这边我们可以固定线程个数，实现逻辑是在主线程中，通过将同步操作封装成一个异步请求(里面设置好同步操作完成后需要执行的回调函数)，并将其投递到一个并发队列(保存异步请求，多线程中的并发队列，就相当于多进程中的消息队列，都是用于解耦的)，然后异步请求处理线程从并发队列中取出待处理的异步请求，在线程中阻塞执行同步操作，最后将执行结果同异步请求中设置的回调函数一并发送到另一个并发队列(保存异步请求执行结果，还要再发回来是为了保证异步操作在主线程中串行执行)，主线程中定期会去检查异步请求结果并发队列，取出其中的数据，并使用执行结果去调用回调函数，最终实现同步操作转异步操作(当然也可以使用`C++11`的`std::future`来实现转换，详见我的`Practice`项目)。

```
class 异步套接字
{
    void update()
    {
        数据接收缓存 -> 数据;
        业务逻辑(数据)
        {
            SQL请求 -> 异步请求并发队列;
        }
        数据 -> 数据发送缓存;
        
        套接字连接.async_write(数据发送缓存);
    }

    void start()
    {
        套接字连接.async_read(异步读回调函数);
    }
    
    void 异步读回调函数()
    {
        数据 -> 数据接收缓存;
        套接字连接.async_read(异步读回调函数);
    }

    数据接收缓存;
    数据发送缓存;
    套接字连接;
}

class 异步套接字管理
{
    class 异步请求处理线程
    {
        void run()
        {
            异步请求并发队列 -> 请求;
            执行请求;
            请求结果 -> 异步请求结果队列;
        }
        
        异步请求并发队列引用;
        异步请求结果队列引用;
    }

    void add()
    {
        新的异步套接字 -> 临时并发队列;
    }

    void update()
    {
        定期执行;
        
        临时并发队列 -> 新的异步套接字;
        新的异步套接字 -> 异步套接字列表;

        for (异步套接字 : 异步套接字列表)
        {
            异步套接字.update();
        }
        
        for (执行结果 : 异步请求结果队列)
        {
            执行结果->回调函数(执行结果->数据);
        }
    }

    临时并发队列;
    vector<异步套接字> 异步套接字列表;
    vector<异步请求处理线程> 线程池;
    
    异步请求并发队列;
    异步请求结果队列;
};
```

处理逻辑和线程池很类似，经过改进的框架已经能很好的处理组件开发的前两个问题了，我们还可以进一步改进来提升其性能，比如以多线程的方式来运行BOOST ASIO的`io_context.run();`进一步提高并发，但是同时我们也引入一个问题，就是我们又得保证异步操作串行了，异步读肯定是串行的，因为下一个异步读是在上一个异步读回调里面的，但是异步写不是，不过我们可以非常方便的使用`boost::asio::io_context::strand`来解决我们的问题(详见代码)。

后面还可以针对游戏伺服器场景进行进一步优化，因为我们的天堂数据并不是明文的，所以存在加解密操作(包含在`异步套接字.update()`调用中)，现在所有套接字上数据的加解密都是在`异步套接字管理`的`update`里面处理的，数据的加解密在套接字之间是可以并行的，所以我们可以通过多线程的方式来加速(注意使用EPOLL并不是就意味着抛弃多线程)，即我们需要为`异步套接字管理`创建一些`网络线程`，每个`网络线程`管理一部分`异步套接字`，将`异步套接字.update()`分散到各个`网络线程`，为此我们需要改进`异步套接字管理.add(异步套接字对象);`的实现，在里面实现一个调度算法，将新的`异步套接字对象`分配给相对空闲的`网络线程`。

经过上面的几次迭代改进，我们由最初的简单版本的EPOLL模型变成现在看起来很"复杂"的EPOLL&多线程模型。

现在剩下最后一个问题了，如何优雅的实现定时器？例如OpenStack的Nova Compute有两种定时器(详见`periodic_task.periodic_task`装饰器)，一种是静态的，一种是动态的，`C++`没法像Python这样实现的这么优雅，但是也是有很简洁的实现方式。在讨论定时器实现前，先介绍下`MaNGOS`最核心的思想，就像`sync`方法之于K8S，MaNGOS这套框架的核心在于`update`方法，所有的一切都由`update`方法驱动，用伪代码表示

```
休眠时间 = 0;
上一次更新时间 = now();
while (停止标识 == false)
{
    本次更新时间 = now();
    已经经过时间 = 本次更新时间 - 上一次更新时间;
    组件核心对象.update(已经经过时间);
    上一次更新时间 = 本次更新时间;
    if (已经经过时间 <= 更新时间间隔 + 休眠时间)
    {
        休眠时间 = 更新时间间隔 + 休眠时间 - 已经经过时间;
        sleep(休眠时间);
    }
    else
    {
        休眠时间 = 0;
    }
}
```

所有对象的`update`方法都接收一个参数，就是距离上次更新已经经过的时间，所有异步操作都在`update`方法中处理，这种模式下，我们实现定时器就变得很简单了，首先来看下静态定时器的实现:

```
class 定时器
{
    剩余时间;
    间隔;
}

enum
{
    心跳;
    采集;
}

#define 最大静态定时器个数 2

class 组件核心对象
{
    void update(已经经过时间)
    {
        for (定时器 : 定时器列表)
        {
            if (定时器->剩余时间 - 已经经过时间 <= 0)
            {
                执行定时器回调;
                定时器->剩余时间 = 定时器->间隔;
            }
            else
            {
                定时器->剩余时间 -= 已经经过时间;
            }
        }
    }
    
    定时器列表[最大静态定时器个数];
}
```

动态的也差不多，只不过将定时器列表由数组改成`vector`，动态定时器一般用于游戏中BUFF类技能处理。我们再来考虑下游戏中每日任务的实现，这种看起来又像静态，又像动态该如何实现呢？很简单，我们可以设定个静态定时器，定期获取当前`time_t`时间，然后转换为`struct tm`，跟上一次的`struct tm`对比，如果日期变了，则触发每日任务，如果星期变了，则触发每周任务，如果月份变了，则触发每月任务，虽然几种定时器实现没有统一，但是好在这些静态定时器只需写在一处，代码看上去也是很简洁的。

### 公共组件

就像OpenStack的公共组件oslo，我们也需要准备一个公共组件库，提供组件开发所需的基础模块(代码位于`src/framework`目录，取自`MaNGOS`项目，其实现原理后续再补充)，这些基础模块需要提供以下功能:

- 配置读取
- 日志
- 定时器
- 数据库存取
- 单例模型
- 并发队列
- 回调系统

以及一些其他游戏所需的功能，例如网格系统、随机数生成器、元组容器(不是`C++`的tuple，有点类似Python的List，可以存放"任意"类型的对象)等，C++不像JAVA，缺乏应用级别的库(Boost还是偏底层了)，很多时候感觉都得从"零"开始，上面的这些基础模块可以让我们专注上层的业务架构。

### 游戏框架设计

有了基础框架和公共组件，我们就能开始设计我们的游戏伺服器了，整个游戏世界的核心逻辑伪代码如下

```
休眠时间 = 0;
上一次更新时间 = now();
while (停止标识 == false)
{
    本次更新时间 = now();
    已经经过时间 = 本次更新时间 - 上一次更新时间;
    游戏世界对象::update(已经经过时间)
    {
        for(游戏对象 : 游戏世界内的所有游戏对象)
        {
            游戏对象.update(已经经过时间);
        }
    }
    上一次更新时间 = 本次更新时间;
    if (已经经过时间 <= 更新时间间隔 + 休眠时间)
    {
        休眠时间 = 更新时间间隔 + 休眠时间 - 已经经过时间;
        sleep(休眠时间);
    }
    else
    {
        休眠时间 = 0;
    }
}
```

这是最简单的游戏服务器模型，每次世界更新我们都需要**串行执行**(这点很重要)所有游戏对象的更新操作，游戏对象的更新操作是在干嘛呢？对于玩家，当然就是处理从客户端套接字连接接收到的数据包，执行诸如移动、交易、攻击、释放技能等操作；对于NPC，当然就是执行AI，执行攻击、躲避等操作。

在前面的基础框架中，我们为了并发编解码将套接字分散在了不同的网络线程里面，而此处游戏世界又要串行处理游戏对象，所以我们需要再次引入并发队列和分层设计。我将客户端与伺服器的通讯，分为套接字层和会话层，套接字层可以看做是客户端与服务器的连接，主要处理数据帧的收发和编解码，并将解码后的大部分数据包都投递给会话层(除了连接建立时发送握手包，以及游戏账号登入验证相关数据包)；会话层可以看做是玩家角色与游戏世界的连接，主要处理业务数据包，执行游戏逻辑，驱动玩家角色(玩家角色没进入游戏世界前归套接字层管，进入后归会话层管)。会话层有套接字层负责创建，其创建逻辑位于账号验证数据包处理句柄中，而玩家角色又由会话层负责创建，创建逻辑位于角色选取数据包处理句柄中，所以对于玩家游戏对象，其更新操作就对应着会话层更新，所以我们的问题就变成了如何保证会话层能串行处理数据包。

```
       客户端                                                  服务端
+-------------------+       +-------------------+       +-------------------+
|      会话层        | <---> | 操作码 |    数据    | <---> |      会话层        |
+-------------------+       +-------------------+       +-------------------+
|     套接字层       | <---> |  首部  |    负载    | <---> |     套接字层        |
+-------------------+       +-------------------+       +-------------------+
```

数据帧由首部和负载构成，采用小端模式，首部长度为2字节，负载是经过编码的数据包；数据包由操作码和数据构成，数据包就是未编码的数据帧负载。为了实现会话层的串行处理(游戏对象更新)，我们需要在套接字层和会话层之间引入并发队列，套接字将数据包存入接收并发队列，然后在执行游戏世界更新时，会话层会从并发队列中取出数据包，从而实现串行处理。同时将游戏对象更新时产生的待发送数据包放入另一个待发送并发队列，当套接字层更新时，会从待发送并发队列中取出数据包，然后编码成数据帧发送到客户端，这样我们通过引入两个并发队列，就解决了套接字层和会话层的同步问题。

到目前为止，我们已经构建出了一个具备扩展性的高性能TCP服务器，后续的改进设计仅和业务相关。我们来思考下，会话层中有哪些数据包是可以并行处理的？首先聊天数据包的处理是可以并行的，其次移动数据包在不同地图之间是可以并行的，但是在单个地图内又必须串行处理(需要处理视野同步)，所以我们又可以进一步优化游戏世界的更新逻辑。

```
    for (游戏对象会话 : 游戏世界内的所有玩家的游戏会话)
    {
        游戏对象会话.update(数据包过滤器 -> 仅处理非聊天、非移动数据包);
    }
        
    for (地图 ： 游戏世界地图列表)
    {
        线程池.schedule([]() {
            for (游戏对象会话 : 地图内的所有玩家的游戏会话)
            {
                游戏对象会话.update(数据包过滤器 -> 仅处理动数据包);
            }
        });
    }

    for(游戏对象 : 游戏世界内的所有游戏对象)
    {
        游戏对象.update(已经经过时间);
    }
```

我们将数据包的处理(移动、交易、攻击、释放技能等)放在了游戏对象的会话中处理，那么我们游戏对象的更新就可以仅处理BUFF更新(看看BUFF时间是不是到了)。在此基础上，我们就可以开始设计并实现游戏的各个独立子系统了。

### 对象系统

参考`MaNGOS`我将天堂的游戏对象分为以下几种类型

> Object

游戏对象，所有对象的基类，通过数组的方式保存对象的所有属性(非常有趣的设计)

> WorldObject

游戏世界对象，能在游戏世界显示的对象，具备了世界坐标和更新方法，能随着时间的推移而发生改变的游戏对象。

> Unit

游戏世界活动对象，NPC和玩家的基类，游戏世界对象的子类，拥有属性系统、仓库系统、技能系统、仇恨系统和战斗系统。

> Creature

游戏生物对象，游戏世界活动对象的子类，拥有AI系统。

> Pet

宠物对象，游戏生物对象的子类。

> DynamicObject

游戏世界动态对象，游戏世界对象的子类，用于在游戏世界实现一些短暂的效果，例如天堂的火墙魔法，或者魔兽世界奥术飞弹的飞行效果

> GameObject

游戏世界静态对象，游戏世界对象的子类，实现类似门之类的游戏对象，具备一些特殊方法，例如开关门。

> Player

游戏玩家对象，游戏世界活动对象的子类，拥有消息发送系统、聊天系统、血盟系统和队伍系统。

> Corpse

游戏尸体对象，游戏世界活动对象的子类

### 属性系统

游戏对象六种状态属性分别是: 力量、体质、敏捷、精神、智力、魅力，每种属性在游戏系统中又分为初始值(base)、总体值(total)和有效值(true)，初始值就是从数据库中加载的值(可以看做角色的空身数值)，总体值就是初始值加上装备和法术效果带来的属性加成后的值，有效值就是对总体值进行截断后的值。

为什么需要有效值？因为这些属性的有效范围是1到 127(有效值是要发送到客户端的)，而装备和法术效果带来的加成可能导致总体值超过127或小于1，所以需要进行截断，保证角色的有效值位于1到127的区间内。

那为什么还需要总体值？因为当法术效果消失后，需要恢复成正常的属性值，比如角色初始力量值为80，然后法术效果带来了100点力量加成，那么当前总体值为180，有效值就是127，如果不保存总体值，只保存有效值，那么当法术效果消失后，我们就无法计算出角色正确的初始力量值了。

当然整个游戏对象还包含很多其他属性，都定义在`Unit`和`Player`的`STAT SYSTEM`中，更多细节可参考我之前的文章[天堂开发笔记(四)](https://www.cnblogs.com/silvermagic/p/7666360.html)

### 仓库系统

这是一个较为复杂的系统，我先简单描述下这个系统需要处理的一些场景

- 玩家装备道具
- 玩家丢弃道具
- 玩家交易道具
- 玩家击杀NPC获取道具
- 玩家存放道具
- 玩家从NPC处购买道具
- 玩家使用道具

仓库使用`map`来维护其保存的道具列表，并且提供了获取道具、消耗道具、删除道具、存入道具、交易道具等接口，详见`Items/Inventory.h`的注解，详细设计后续再补充。

如何保证交易的安全性？这个是由客户端和服务端配合来实现的，交易发起时，服务端会确认角色是否存在其他交易，如果存在，则会拒绝新的交易。在交易过程中，客户端玩家将道具依次放入交易框，会触发多次添加交易道具请求数据包，服务端收到数据包后，会将交易道具从背包移入交易仓库，这是一个特殊的仓库(保证道具不会重复交易或者在交易中被删除)，如果交易发生不可预期的异常(只是一个非常极端的假设，大部分场景下道具都会从交易仓库移回玩家背包)，道具也仅仅是在内存中消失，数据库中的道具依然是存在的，重启后即可恢复，不会造成道具丢失，整个逻辑有点类似现实生活中的担保交易，交易双方不是直接把物品给对方，而是先交给担保人，由担保人保证交易的事务性。

目前仅实现了道具装备和背包展示(在客户端显示背包内道具)，其余部分等技能系统完成后再进一步设计和实现，因为部分道具使用依赖技能系统，例如传送卷轴、药水等。

### 技能系统

这是一个非常复杂的系统，我先简单描述下这个系统需要处理的一些场景

- 玩家给自己加了一个BUFF，提升了某些属性，BUFF消失后，属性恢复正常
- 玩家对其他游戏对象使用了攻击法术，对其造成了伤害
- 玩家对其他游戏对象使用了攻击法术，但是法术被反射回了自身
- 玩家对其他游戏对象使用了驱散法术，解除了目标身上某些BUFF
- 玩家给自己加了一个BUFF，当其他玩家攻击自身时，会自动反弹部分伤害
- 玩家给其他玩家施加了一个BUFF，造成其他玩家治疗效果减半
- 玩家使用了无敌法术，在不移动的情况下免疫一切伤害，但是一旦发生移动或法术时间到了就会失去无敌状态
- 玩家给自己加了一个BUFF，但是自己身上已经有相同BUFF了，那么新的BUFF将替换旧BUFF

还有些情况下，某些道具的使用也会触发法术，例如魔法武器。JAVA版本的天堂使用最原始的方法，用一个巨大的`if-else`来处理所有法术效果，并且在战斗系统和仓库系统中添加代码来处理，魔法武器攻击特效或道具使用触发的法术，这样设计实现起来简单，但是缺乏扩展性和可维护性，新的技能效果必须由开发者通过编码的方式来实现。

如何实现一个可扩展兼具可维护性的技能系统呢？最理想的状态是开发者维护技能系统核心，策划可以通过配置数据库的方式来构建一个新的技能，就好像OpenStack的plugins功能或者Kubelet的PostStart等，版本开发者在一些关键逻辑提供一些HOOK函数，开发者可以通过注入自己的特殊逻辑到这些HOOK函数来实现新特性，而无需修改核心代码，这就意味了我们必须抽象出所有技能都具备的特性，并且支持通过配置来组合这些特性，就好像我们将一些通用代码封装成函数，通过传递不同的参数来实现不同的功能。

我们将法术的公共特性抽象成法术效果，例如治愈、召唤、施加BUFF等，然后通过法术效果 + 法术参数的方式来组合出法术，例如初级治愈和高级治愈，其治愈处理逻辑都是一样的，差别仅在于治疗量不同，这样初级治愈 = 法术效果(治愈) + 法术效果参数(10)，高级治愈 = 法术效果(治愈) + 法术效果参数(100)，对于BUFF我们使用法术光环来表示(就是在客户端右上角会显示法术图标的法术效果)，法术光环是法术效果中的一种，为了保证技能的丰富程度，一个技能通常由最多三个法术效果构成。

我们来看下这样的设计如何处理我们上面描述的场景

- 技能的法术效果是施加BUFF，我们将创建一个法术光环，其法术效果参数为BUFF效果编号，并将其保存到玩家的法术光环列表中，当法术光环存在于玩家光环列表中时，就会给玩家带来光环效果，类提升属性，提升的属性类型和属性值通过法术光环参数指定，玩家每次更新时，都会更新光环列表，移除那些时间已经到了光环，同时删除光环效果，如果之前提升属性，那么现在就降低属性
- 技能的法术效果是类型伤害，其伤害值由法术效果参数指定
- 目标身上存在一个法术光环，其光环效果为反射攻击法术
- 玩家身上存一个法术光环，其光环效果为反射部分近战攻击，在战斗系统的命中判定处理中，加入此类被动法术触发判定，可以通过指定光环效果参数来实现不同的反击效果，例如反击对方本次攻击值的10%
- 目标身上存在一个法术光环，其光环效果为降低所有治疗效果，所以我们在治疗法术效果的实现逻辑中，需要加入对此类减免治疗效果的光环的判断
- 目标身上存在一个法术光环，其效果为免疫一切伤害，然后在移动处理逻辑中，加入移除所有中断条件为移动的光环效果
- 创建法术光环，当玩家身上已经存在相同光环，更新旧光环的剩余时间，然后删除新创建的法术光环

同时我们还能将道具使用效果也统一起来，例如回复药水的使用也是一种治疗法术效果。

#### 法术施放处理

法术一共有四种状态，分别为

- 施法准备时期
- 引导施法时期(读条)
- 施法结束时期(成功或失败)
- 施法延迟时期(读条结束，法术命中目标前的飞行时期，例如魔兽的奥术飞弹)

施放法术需要经过以下几个阶段，在不同的阶段会设置不同的法术状态

> 法术准备

设置好施法目标，同时检测是否具备施法条件(施法材料是否够、地图是否禁止施法、目标是否免疫法术、自己是否存在禁止施法BUFF等)，如果施法条件满足，将进入法术施放阶段(天堂法术都是瞬发，没有读条阶段)

> 法术施放

计算最终受魔法影响的游戏对象(同时进行法术命中判定，游戏对象受法术影响，但不一定会命中，例如抵抗了当前法术，但是依然要将其放入受魔法影响的游戏对象的列表，有时候需要计算仇恨值)，例如燃烧的火球，其最初的施法目标是一个对象，但是最终受到伤害的是目标对象周围4格范围内的所有对象，然后扣除法术消耗(魔力、体力或施法材料)，最后对受魔法影响的游戏对象应用法术效果，例如治疗法术效果就是加血，如果法术命中后一定概率会触发其他法术，则还需要进行触发判定，如果判定成功，就相当于对目标再施放一个新的法术。

当然具体的实现是很复杂的，但是其核心逻辑是很简单的。

### 战斗系统

```
todo
```

### AI系统

```
todo
```